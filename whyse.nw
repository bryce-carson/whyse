%% -*- mode: Poly-Noweb; noweb-code-mode: emacs-lisp-mode; fill-column: 72; -*-
%% FIXME: finduses.nw and the recognizer.nw need some tweaking to better support LISP identifiers. It may be as simple as moving `-' from SYMBOLS to ALPHANUMERIC.
% Copyright © 2023 Bryce Carson
\documentclass{article}

%% FONT
\usepackage[T1]{fontenc}
\usepackage{tgbonum}

%% MARGIN
\usepackage[margin=1.5in]{geometry}
\usepackage{mparhack}
\usepackage{mathptmx}

%% FIXME: biblatex causes knoweb to be unable to compile.
%% \usepackage{biblatex}
%% \addbibresource{\whyse.bib}

\usepackage[smallcode,nohyperidents]{knoweb}
\usepackage[colorlinks,backref]{hyperref}

\usepackage{syntax}
\usepackage{xspace}
\usepackage{paralist}
\usepackage{color}

%% NOTE: used in the figure of the WHYSE frame layout.
\usepackage{fancyvrb}

%% BEGIN
\pagestyle{noweb}
\begin{document}

%% \section{Preface}
%% A paper describing this implementation---written in Noweb and browsable,
%% editable, and auditable with WHYSE, or readable in the printed form---is
%% hoped to be submitted to The Journal of Open Source Software (JOSS)
%% before the year 2024. N.B.: the paper will include historical
%% information about literate programming, and citations (especially of
%% those given credit in the [[<<Commentary>>]] for ideating WHYSE itself).

%% \subsection{On literate programming}
%% Literate programs can be organized in multiple ways; particularly, I
%% note these forms of organization here. How WHYSE implementations may
%% influence literate programming style, taste, or form will be interesting
%% to observe (as it is a multi-langual art and will benefit from both the
%% traditional language arts greatly as well as ``code smell'' [a strange
%%   term programmers have invented to somewhat describe computer--language
%%   arts]).

%% \begin{enumerate}
%% \item Algorithmic
%% \item Architectural
%% \item Linear
%% \item Notebook--like (Jupyter and iPython--like, which were influenced by Sweave)
%% \item Sweave--like (R Noweb ::= R Markdown)
%% \end{enumerate}

%% The organization of this literate program is \textit{linear}, with
%% aspects of the program explained as the user would encounter them, more
%% or less.

\section{Projects}\label{Projects}
\textsc{(no)Web HYpertext System in Emacs} (WHYSE) is a project-based
application. Projects are lists registered with WHYSE using the ``Easy
Customization Interface'', which provides a simple way to make the
necessary information known to WHYSE. Users register a literate
programming project (only Noweb–-based programming is supported) as an
item in the customization variable [[w-registered-projects]]; further
project data is contained in a Common Lisp struct during runtime.

In short, a project is composed of several things:

\begin{itemize}
\item a name,
\item a Noweb source file,
\item a shell command to run a user-defined script
\item an \textsc{SQLite3} database, and a connection thereto,
\item a frame,
\item and date-time information (creation, edition, and export).
\end{itemize}

The struct keeps some information during runtime, like the connection,
but other information is generated at runtime (such as the filename of
the database). These items are each explained in this section. If some
item is not well-enough explained in this section, please try editing
the Noweb source and improving the explanation and creating a
pull-request against the WHYSE Emacs Lisp repository on its Git forge; you
may also submit your edition by email to the package maintainer.

Users of WHYSE in Emacs are expected to be familiar with Noweb; this does
not include how Noweb is built from source (that is arcane, supposedly)
or how filters are implemented with Sed, AWK, or other languages. Users
must know, however, how to write a custom command-line for noweave (read
the manual section regarding the \texttt{-v} option).

Developers of WHYSE extensions (in either SQL or Emacs Lisp) should read
the Noweb Hacker's Guide until they understand it, afterwards reading
this documentation several times until the full implementation is
understood. I recommend modifying the system using itself to keep
organized, and writing literately; you'll thank yourself later for doing
so.

A customization group for WHYSE is defined to organize its customization
variables, and these details are explained before moving on to explain the
struct used during runtime.

<<Customization and global variables>>=
(defgroup whyse nil
  "noWeb HYpertext System in Emacs"
  :tag "WHYSE"
  :group 'applications)

(defcustom w-registered-projects nil
  "This variable stores all of the projects that are known to WHYSE."
  :group 'whyse
  :type '(repeat w--project-widget)
  :require 'widget
  :tag "WHYSE Registered Projects")

@

The Widget feature is required by the registered projects variable, but
may be redundant because the Easy Customization Interface is itself
implemented with The Emacs Widget Library. Requiring the library may be
undesirable, as [[(require 'widget)]] will be eagerly evaluated upon
Emacs' initialization when [[w-registered-projects]] is set to its
saved custom value. However, there may be a good reason to eagerly
evaluate that form: the Widget feature will be available immediately,
and widgets will be used in buffers to provide TUI buttons for
navigation between modules of a literate program (at least, that is the
design of the program at this point in development), so having this
feature available sooner than later is okay. The feature is required by
the package regardless.

The [[w--project-widget]] type used for the registered projects
variable is a simple list widget containing the name of the project and
its Noweb source file, along with a filename for a shell script which
generates the Noweb tool syntax for this project. Each Noweb project has
a different command-line, and some are complex enough to have a
makefile, or multiple makefiles! Noweb itself is an example of that
level of complexity. The shell script is later executed by WHYSE upon
loading the project, and the standard output captured for parsing by a
PEG parser.

<<Widgets>>=
(define-widget 'w--project-widget 'list
  "The WHYSE project widget type."
  :format "\n%v\n"
  :offset 0
  :indent 0

  ;; NOTE: the convert-widget keyword with the argument
  ;; 'widget-types-convert-widget is absolutely necessary for ARGS to be
  ;; converted to widgets.
  :convert-widget 'widget-types-convert-widget
  :args '((editable-field
           :format "%t: %v"
           :tag "Name"
           :value "")

          (file
           :tag "Noweb source file (*.nw)"
           :format "%t: %v"
           :valid-regexp ".*\\.nw$"
           :value "")

          (string
           :tag "A shell command to run a shell script to generates Noweb tool syntax"
           :format "%t: %v"
           :documentation "A shell script which will produce the
           Noweb tool syntax. Any shell commands involved with
           noweave should be included, but totex should of course
           be excluded from this script. The script should output
           the full syntax to standard output. See the Noweb
           implementation of WHYSE for explanation."
           :value "")))

@

NB: Comments may be superfluous in a literate document like this, but
some effort was made to produce a readable source file regardless of the
general principles of literate programming; other authors write warnings
into their tangled source files: ``Don't read this file! Read the Noweb
source only!''. I don't say that, especially for an Emacs application.

The sole interactive command---[[whyse]]---loads the first element of
[[w-registered-projects]], considering it the default project.

<<Quotation custom-set-variables>>=
'(w-registered-projects
  '(("Noweb Hypertext System"
     "~/Desktop/whyse.nw"
     "make -C ~/Desktop --silent --file ~/src/whyse/Makefile tool-syntax"))
  nil
  (widget))
@ 

The [[whyse]] command is very simple, it checks if projects have been
defined in the Customize interface, and if so uses the first one to
\textit{initialize a new project}. If no projects are defined or there
are any nil values in the procedure, the Customize interface is opened.

<<WHYSE>>=
(defun whyse ()
  (interactive)
  (if-let ((w-load-default-project?)
           (default-project (cl-first w-registered-projects))
           (project (make-w-project :name (cl-first default-project)
                                    :noweb (cl-second default-project)
                                    :script (cl-third default-project))))
      <<convert the Noweb to tool format and parse it with the PEG>>
      <<open Customize to register projects>>))

@

WHYSE is likely to be useful for very large literate programs, so the
command is designed to initialize from an existing project without
prompt. In more verbose terms: unless [[w-load-default-project?]] is
non-nil and [[w-registered-projects]] includes at least one element,
Customize will be opened to customize the WHYSE group when [[whyse]] is
invoked.

<<Customization and global variables>>=
(defcustom w-load-default-project? t
  "Non-nil values mean the system will load the default project.

nil will cause the interactive command `whyse' to open Customize on
its group of variables."
  :type 'boolean
  :group 'whyse
  :tag "Load default project when `whyse' is invoked?")

<<open Customize to register projects>>=
(message
 "No WHYSE projects registered, or `w-load-default-project?' is nil. %s"
 (customize-group 'whyse))
@

<<WHYSE project structure>>=
(cl-defstruct w-project
  "A WHYSE project"
  ;; Fundamental
  name
  noweb
  script
  database-file
  database-connection

  ;; Usage
  frame

  ;; Metadata
  (date-created (ts-now))
  date-last-edited
  date-last-exported

  ;; TODO: limit with a customization variable so that it does not grow too large.
  history-sql-commands)
@

Instances of this struct are only initialized with a few values:
[[name]], [[noweb]], and [[script]]. The rest of the fields
either have default values dependent upon the input data (like
the database-file, database-connection, and date-created), or are
given values when appropriate later in operation (such as
[[date-last-exported]]) or upon initialization ([[frame]]).

Initialization when the interactive command is called is covered next;
to summarize: [[w-project-load-hook]] is run.

\section{System initialization from new projects}\label{Initialization}
To summarize this section, since it is longer than the previous section,
the object is the definition of [[<<convert the Noweb to tool format and
parse it with the PEG>>]], which is a chunk used in [[whyse]].

In more explicit words, this section describes the actions that occur
when a user invokes [[whyse]] interactively (with \textit{M-x}) and the
preconditions have been met; the [[whyse]] function has already been
introduced, and only the ``meaty'' business end of its operation has
been left undefined until now. Ergo, [[<<convert the Noweb to tool
format and parse it with the PEG>>]] gathers together the functionality
that converts a Noweb to its tool syntax with a project's specified
shell script, and parses the text before the next section of body forms
is executed. Those send the parsed text to the database, and finally
create the atomic window for the IDE in the active frame.

<<convert the Noweb to tool format and parse it with the PEG>>=
(with-temp-buffer
  (insert (shell-command-to-string (w-project-script project)))
  (goto-char (point-min))
  (w--parse-current-buffer-with-rules))
@ 

\subsection{Conversion to tool syntax}\label{toolconversion}
WHYSE could have been written to call the \texttt{noweave} programs
itself, but that is less configurable than providing the opportunity to
let the user configure this on their own. It respects Noweb's pipelines
architecture, and keeps things as transparent as possible. What is
needed to be Emacs Lisp is, and what is not isn't. The tool syntax is
thus obtained by running the shell script configured for the project by
calling it with the command-line provided in the third element of an
entry in [[w-registered-projects]].

<<run the project shell script to obtain the tool syntax>>=
(make-process
 :name "w-tool-generation"
 :buffer (get-buffer buffer)
 :command `("bash" ;; likely BASH on a GNU system, hoping for the `command-string' option.
           "-c"
           (,@(w-project-script project)))

 :stderr (generate-new-buffer "WHYSE tool generation standard error stream")
 :sentinel (lambda (process event-string)
             (message "%S: %s" process event-string)))
@ 

The PEG for Noweb's tool syntax is run on the result of the shell
script, and this value consumed by the parent of this chunk.

\subsection{Database initialization}
Every project should have a database file located somewhere within the
user's Emacs directory; if the user is a Spacemacs user, then Spacemacs'
cache directory is used, otherwise the database is made in the user's
Emacs directory and not a sub-directory thereof.

The form used to create the absolute path for the location of the
database joins three things: the user's Emacs directory, \texttt{nil} or
Spacemacs' cache directory, and the name of the project with ``.db''
appended. Note that concatenating \texttt{nil} with a string is the same
as returning the string unchanged.

<<return a filename for the project database>>=
(file-name-concat
 ;; Usually ~/.emacs.d/
 user-emacs-directory
 ;; `nil' or the Spacemacs cache directory.
 (when (f-directory? (expand-file-name ".cache" user-emacs-directory))
   ".cache")
 ;; PROJECT-NAME.db
 (concat (w-project-name project)
         ".db"))
@

For \textsc{SQLite}, the path name of the database to connect to or
create is sufficient to establish a connection, so the next step is to
connect to the database and store the connection object in the
appropriate slot of the project struct.

<<create the database>>=
(setf (w-project-database-connection project)
      (emacsql-sqlite
       (w-project-database-file <<return a filename for the project database>>)))
@ 

The only thing left to do is establish the schema of the tables, which
is done by mapping over several \textsc{EmacSQL} s-expressions.

%% To create an (SQLite) database from scratch for use with WHYSE, the schema
%% must be applied to the database using data definition language (DDL).
%% With the four tables created, data is provided to the database after the
%% parsing expression grammar (PEG) has finished its work on the tool
%% syntax produced by Noweave's \texttt{markup} program. The PEG and the
%% tool syntax are dealt with in \ref{PEG}.

%% TODO: ensure that this database is in 3NF and make a nice database
%% planning documents for it.
<<map over SQL s-expressions, creating the tables>>=
(--map (emacsql (w-project-database-connection project) it)

      ;; A list of SQL s-expressions to create the tables.
      '([:create-table module
         ([module-name
           content
           file-name
           section-name
           (displacement integer)
           (module-number integer :primary-key)])]

        [:create-table parent-child
         ([(parent integer)
           (child  integer)
           (line-number integer)]
          (:primary-key [parent
                         child]))]

        [:create-table identifier-used-in-module
         ([identifier-name
           (module-number integer)
           (line-number integer)
           type-of-usage]
          (:primary-key [identifier-name
                         module-number
                         line-number
                         type-of-usage]))]

        [:create-table topic-referenced-in-module
         ([(topic-name nil)
           (module-number integer)]
          (:primary-key [topic-name
                         module-number]))]))
@

\subsection{Frame creation and atomic window specification}
A frame like in Figure \ref{fig1} should be created.

\begin{figure}
\begin{center}
\label{fig1}
\begin{BVerbatim}
+--------------+-----------------+-------+
| Module       | Module         ↑| Index |
| Code         |  documentation  |       |
|              |                 |       |
|              |  (prior or      |       |
|              |    posterior)   |       |
????????????????                 |       |
? AWK  Scripts ?                ↓|       |
????????????????-----------------+       |
| Console                        |       |
+--------------------------------+-------+
\end{BVerbatim}
\end{center}
\caption{Simple drawing of WHYSE frame layout}
\end{figure}


<<Get project frame>>=
(progn
  (select-frame (w-project-frame project))
  (switch-to-buffer (generate-new-buffer (w-project-name project))
                    nil
                    'force-same-window)
  (let* ((window-right (split-window-right))
         (parent-window (window-parent window-right)))
    (window-make-atom parent-window)
    (display-buffer-in-atom-window
     (get-buffer-create (format "Module Index<%s>"
                                (w-project-name project)))
     `((window . ,parent-window) (window-height . 8)))))

@

\section{System initialization from existing projects}
WHYSE loads a project by running the shell script stored in the third
element of the project list (which is pointed to by the script slot in
the struct).

\subsection{Initializing from an existing project}
With a default project available, WHYSE runs [[w-project-load-hook]]
with the struct of the default project let-bound as [[project]]. Much of
the functionality of WHYSE is implemented with the default hook, and
extensions to WHYSE should be implemented by editing the WHYSE Noweb source
and recompiling it, or extending the existing system with more hook
functions added to the aforementioned hook list variable.

If the project's database file is empty (zero-bytes) or does not exist
then the database is created from scratch. If the database already
exists, the first module is loaded and the database is not changed.

<<delete the database if it already exists, but only if it's an empty file>>=
;; Unless the SQLite database's size is zero or it doesn't exist, move it to the user's trash directory.
(let ((w--dbfile (w-project-database-file project)))
  (unless (or (not (file-exists-p w--dbfile))
              (= 0 (file-attribute-size (file-attributes w--dbfile))))

    ;; TODO: Is there a better way to do this? `backup-buffer'?
    (copy-file w--dbfile (concat w--dbfile "~") t)

    ;; TODO: ensure that this AREA of code is reasonable before release.
    ;; It may have been written to ease development only.
    (let ((delete-by-moving-to-trash t))
      (delete-file w--dbfile t)))

@ 

\section{Loading Noweb source files}\label{Loading}
To parse a noweb source file, the file needs to be loaded into a temporary
buffer, then it can be parsed.

A simple usage of \textsc{Noweb} is given next, which shows that
\texttt{noweave} does not include the header keyword, nor
autodefinitions, usages, or indexing by default. Those are further
stages in the UNIX pipeline defined by the user with \texttt{noweave}
command-line program options and flags.

The WHYSE system parses the tool syntax emitted by \texttt{markup}, and
early development versions
%% TODO: set a version.
(prior to version \texttt{0.n-devel})
completely ignore Noweb keywords out of that scope.

An example of a \textsc{Noweb} command-line a user may call is given next.

\begin{quote}
\begin{verbatim}
[bryce@fedora whyse]$ noweave -v -autodefs elisp -index whyse.nw 1>/dev/null
RCS version name $Name:  $
RCS id $Id: noweave.nw,v 1.7 2008/10/06 01:03:24 nr Exp $
(echo @header latex
/usr/local/lib/markup whyse.nw
echo @trailer latex
) |
/usr/local/lib/autodefs.elisp |
/usr/local/lib/finduses |
/usr/local/lib/noidx |
/usr/local/lib/totex
\end{verbatim}
\end{quote}

Ergo, the simplified pipeline---using Emacs Lisp autodefinitions provided in
\textsc{Knoweb} (written by \textsc{Joseph S. Riel})---is as follows:

\begin{verbatim}
  markup whyse.nw | autodefs.elisp | finduses | noidx
\end{verbatim}

%% TODO: rename and revise this section.
\subsubsection{In-development}
For an existing project (during development, that is WHYSE) to be loaded, it must
minimally be:
\begin{enumerate}
  \item Parsed, then stored in a database
  \item Navigable with WHYSE
    \begin{enumerate}
    \item Frame and Windows
    \item Navigation buttons... at least for modules
    \end{enumerate}
\end{enumerate}

This means diagramming the database schema, creating it in EmacSQL,
creating validating functions for existing databases, exceptions for
malformed databases, and documenting that in \LaTeX.

Navigation with WHYSE is multi-part:
\begin{enumerate}
\item Query the database for a list of modules, and
\item Create a buffer for the text content retrieved
\end{enumerate}

Exporting a project from the database and editing the project in an in-memory
state are further objectives, but they will be archived after the above two have
been implemented in a basic form.

\subsubsection{TODO}
The following features need to be implemented:
\begin{enumerate}
  \item Project export from database to Noweb format
  \item Editing of modules, documentation, and Awk code
  \item Navigation with indices
  \item Implement indices widgets
\end{enumerate}

\section{Parsing}
This section covers the parsing of the Noweb tool syntax produced by a
project shell script (described in §\ref{Projects}). The following
blocks of LISP code use the \textsc{peg} Emacs Lisp package to provide
for automatic parser generation from a formal PEG grammar based off of
the exhaustive description given in the Noweb Hacker's Guide.

%%% FIXME: the technobabble here is unhelpful.
%% Parsing the tool syntax allows for the generation of an
%% partially--directed graph, a digraph, of the network of chunks which
%% have hierarchical, self and non-self references, with their sequential
%% ordering and non-sequential orderings available for navigation (see
%% \href{https://www.isko.org/cyclo/hypertext#2.5}{\textsc{Intl. Soc.
%%     Knowledge Organization}} for futher information).

%% NOTE: to match the new line character in a text stream, the string
%% literal "\n" must be included. The (eol) PEG rule /tests/ for the end
%% of line by guarding the boolean return value of the standard Emacs
%% Lisp (eolp). To test if point is at the end of a line, use (eol), to
%% match the end of line, and permit parsing the next line of input,
%% include the string literal "\n".
\subsection{PEG rules}\label{rules}
Every character of an input text to be parsed by parsing expressions in
a PEG must be defined in terminal rules of the formal grammar. The root
rule in the grammar for Noweb tool syntax is the appropriately named
[[noweb]] rule. Beginning [[with-peg-rules]] brought into scope, the
root rule [[noweb]] is ran on the buffer containing the tool syntax
produced by the project shell script.

<<buffer parsing function>>=
;;;; Parsing expression grammar (PEG) rules
(defun w--parse-current-buffer-with-rules ()
  "Parse the current buffer with the PEG defined for Noweb tool syntax."
  (with-peg-rules
      (<<PEG rules>>)
    (let (w--peg-parser-within-codep)
      (peg-run
       (peg noweb)
       (lambda (lst)
         (message "Parsing failed in buffer %S.\nPEXes which failed:\n%S"
                  (current-buffer) lst))))))
@ 

The grammar can be broken into five sections, each covering some part of
parsing.

<<PEG rules>>=
<<high-level Noweb tool syntax structure>>
<<files and their paths>>
<<chunks and their boundaries>>
<<quotations>>
<<keyword definitions>>
<<meta rules>>
@ 

As stated, the [[noweb]] rule defines the root expression, or starting
expression, for the grammar. The tool syntax of Noweb is simply a list
of one or more files, which are each composed of at least one chunk.
Ergo, the following [[<<high-level Noweb tool syntax structure>>]] is
defined.

<<high-level Noweb tool syntax structure>>=
;;; Overall Noweb structure
(noweb (bob)
       (not header)
       (+ (and file (opt (or (and x-chunks i-identifiers)
                             (and i-identifiers x-chunks)))))
       ;; Trailing documentation chunk and new-lines
       (opt chunk)
       (opt (* nl))
       (not trailer)
       (eob))
@

It is a fatal error for WHYSE if the header or trailer wrapper keywords
appear in the text it is to parse. They are totally irrelevant, and only
matter for the final back-ends (\TeX, \LaTeX, or HTML).

The grammar needs to address the fact that the syntax of the Noweb tool
format is highly line-oriented, given the influence of AWK on the design
(and usage) of Noweb. The following [[<<meta rules>>]] define rules
which organize the constructs of a line-oriented, or data-oriented,
syntax.

<<meta rules>>=
;; Helpers
(nl (eol) "\n")
(!eol (+ (not "\n") (any)))
(spc " ")
@

With the [[<<meta rules>>]] enabling easier definitions of what a given
``keyword'' looks like, the concept of a file needs to be defined. A
file is anything that \textit{looks like a file} to Noweb, however, by
default only the [[@<<*>>]] chunk is tangled when no specific root chunk
is given on the command line.

<<files and their paths>>=
;; Technically, file is a tagging keyword, but that classification only
;; makes sense in the Hacker's guide, not in the syntax.
(file (bol) "@file" spc (substring path) nl
      (list (+ chunk))
      `(path chunk-list -- (list path chunk-list)))
(path (opt (or ".." ".")) (* path-component) file-name)
(path-component (and path-separator (+ [word])))
(path-separator ["\\/"])
(file-name (+ (or [word] ".")))
@

\marginpar[Writing PEXes for matching file names was the most difficult
  part I have encountered so far, as it has forced me to understand that
  a first reading of documentation is usually not sufficient to
  understand a complex library in an area of programming I have not
  practiced in before (language parsing).]{Writing PEXes for matching
  file names was the most difficult part I have encountered so far, as
  it has forced me to understand that a first reading of documentation
  is usually not sufficient to understand a complex library in an area
  of programming I have not practiced in before (language parsing).}

Because chunks must not overlap, but can nest, the beginnings of chunks
need to be pushed to the parsing stack and the end of a chunk needs to
be popped off of it. The stack pushing operations in [[kind]] and
[[ordinal]] delimit chunks by their kinds and number, and the stack
actions in the [[end]] rule check that the chunk-related tokens on the
stack are balanced.

<<chunks and their boundaries>>=
(chunk begin (list (* chunk-contents)) end)
(begin (bol) "@begin" spc kind spc ordinal (eol) nl
       (action (setq w--peg-parser-within-codep t)))
(end (bol) "@end" spc kind spc ordinal (eol) nl
     (action (setq w--peg-parser-within-codep nil))
     `(kind-one ordinal-one keywords kind-two ordinal-two --
                (if (and (= ordinal-one ordinal-two) (string= kind-one kind-two))
                             ;;; Push the contents of the chunk to the stack in a cons
                             ;;; cell with the car being a list of the kind and number.
                             ;;;; E.g.:
                    ;; (("code" 3) . (@text @nl @text @nl))
                    (cons (cons kind-one ordinal-one) keywords)
                  (error "There was an issue with unbalanced or improperly nested chunks."))))
(ordinal (substring [0-9] (* [0-9]))
         `(number -- (string-to-number number)))
(kind (substring (or "code" "docs")))
@ 

Valid [[chunk-contents]] is somewhat confusing, because chunks
can contain many types of information other than text and new
lines. The definition of what is valid follows.

\begin{enumerate}
\item \texttt{text}
\item \texttt{nl}
\item \texttt{defn \textit{name}}
\item \texttt{use \textit{name}}
\item \texttt{line \textit{n}}
\item \texttt{language \textit{language}}
\item \texttt{index \ldots}
\item \texttt{xref \ldots}
\end{enumerate}

Any other keywords are invalid inside a code block. An example of an
invalid keyword is anything related to quotations!

<<chunks and their boundaries>>=
(chunk-contents
 (or
  <<structural keywords (except quotations)>>
  <<tagging keywords>>
  <<tool errors>>))
@ 

It is easier to handle the fatal keyword appearing inside chunks when it
is a permissible keyword to appear inside a chunk; this allows the
parser to consider a chunk with fatal inside of it \textit{as a valid
  chunk}, but that does not mean that a chunk with a fatal keyword
inside it does not invalidate a Noweb, it still does: the fatal keyword
causes a fatal crash in parsing regardless. Those structural keywords
which may be used inside the contents of a chunk are given next.

<<structural keywords (except quotations)>>=
;; structural
text
nwnl ;; Noweb's @nl keyword, as differentiated from the rule nl := "\n".
defn
use ;; NOTE: related to the `identifier-used-in-module' table.
@ 

\textit{All} structural keywords, then, are:

%% NOTE: not meant to be referenced anywhere!
<<structural keywords>>=
<<structural keywords (except quotations)>>
quotation
@ 

<<tagging keywords>>=
;; tagging
line
language
;; index
i-define-or-use
;; xref
x-prev-or-next-def
x-continued-definitions-of-the-current-chunk
x-usages
@ 

<<tool errors>>=
;; error
fatal
@ 

The fundamental keywords are text and nwnl (new line, per Noweb
convention). Text keywords contain source text, and any new lines in the
source text are replaced with the appropriate number of nwnl keywords
(per convention).

<<chunks and their boundaries>>=
(text (bol) "@text" spc (substring (* (and (not "\n") (any)))) nl)
(nwnl (bol) "@nl" nl)
@

Nowebs are built from chunks, so the definition and usage of (references
to) a chunk are important keywords.

<<chunks and their boundaries>>=
(defn "@defn" spc (substring !eol) nl
  `(name -- (cons "chunk" name)))

(use (bol) "@use" spc (action (message "\"@use \" matched"))
     (substring !eol) nl
     `(chunk-name -- (if chunk-name
                         (cons "Chunk usage (child)" chunk-name)
                       (error "UH-OH! There's a syntax error in the tool output!"))))
@

\begin{quotation}
  Documentation may contain text and newlines, represented by @text and
  [@nwnl]. It may also contain quoted code bracketed by @quote . . .
  @endquote. Every @quote must be terminated by an @endquote within the
  same chunk. Quoted code corresponds to the [[…]] construct in
  the noweb source.
\end{quotation}

<<quotations>>=
(quotation (bol) (substring "@quote") nl
           ;; TODO: improve the supported keywords as parsing errors are
           ;; encountered which do not violate the assumptions of
           ;; quotations as stated in the Noweb Hacker's Guide.
           (list (* (or text nwnl defn use)))
           (bol) (substring "@endquote") nl)
@

<<keyword definitions>>=
(line (bol) "@line" spc (substring ordinal) nl
      `(o -- (cons "@line" o)))

(language (bol) "@language" spc (substring words-eol))
@

The indexing and cross-referencing abilities of Noweb are excellent
features which enable a reader to navigate through a printed (off-line)
or on-line version of the literate document quite nicely. These
functionalities each begin with a rule which matches only part of a line
of the tool syntax since there are many indexing and cross-referencing
keywords. The common part of each line is a rule which merely matches
the [[@index]] or [[@xref]] keyword. The rest of the lines are handled
by a list of rules in [[index-keyword]] or [[xref-keyword]].


The \textit{Noweb Hacker's Guide} lists these two lines in the ``Tagging
keywords'' table, indicating that it's unlikely (or forbidden) that the
index or xref keywords would appear alone without any subsequent
information on the same line.

\begin{quotation}
  @index ... Index information.

  @xref ... Cross-reference information
\end{quotation}

There are many keywords defined by the Noweb tool syntax, so they
are referenced in this block and defined and documented
separately. Some of these keywords are delimiters, so they are
not given full ``keyword'' status (defined as a PEX rule) but
exist as constants in the definition of a rule that defines the
grouping.

<<keyword definitions>>=
;; Index
<<indexing and cross-referencing set-off words>>
<<fundamental indexing keywords, which are restricted to within a code chunk>>
<<the index of identifiers>>
<<unsupported indexing keywords>>

;; Cross-reference
<<cross-referencing keywords>>

;; Error
<<error-causing keywords>>
@

Further keywords are categorized neatly as Indexing or
Cross--referencing keywords, so they are contained in subsections.

\subsection{indexing}
Indexing keywords, both those used within chunks and those used outside
of chunks, are defined in this section. The [[<<fundamental indexing
keywords, which are restricted to within a code chunk>>]], index
definitions or usages of identifiers and track the definitions of
identifiers in a chunk and the usages of identifiers in a chunk. They
may seem redundant, but are not; the Noweb Hacker's Guide offers a
better explanation of the differences.

<<indexing and cross-referencing set-off words>>=
(idx (bol) "@index" spc)
(xr (bol) "@xref" spc)

<<fundamental indexing keywords, which are restricted to within a code chunk>>=
(i-define-or-use
 idx
 (substring (or "defn" "use")) spc (substring !eol) nl
 (action
  (if (not w--peg-parser-within-codep)
      (error "WHYSE parse error: index definition or index usage occurred outside of a code chunk.")))
 `(s1 s2 -- (cons s1 s2)))

<<identifiers defined in a chunk>>
<<identifiers used in a chunk>>

<<identifiers defined in a chunk>>=
(i-definitions idx "begindefs" nl
               (list (+ (and (+ i-isused) i-defitem)))
               idx "enddefs" nl
               `(definitions -- (cons "definitions" definitions)))
(i-isused idx (substring "isused") spc (substring label) nl
          `(u l -- (cons u l)))
(i-defitem idx (substring "defitem") spc (substring !eol) nl
           `(d i -- (cons d i)))

<<identifiers used in a chunk>>=
(i-usages idx "beginuses" nl
          (list (+ (and (+ i-isdefined) i-useitem)))
          idx "enduses" nl
          `(usages -- (cons "usages" usages)))
(i-isdefined idx (substring "isdefined" spc label) nl)
(i-useitem idx (substring "useitem" spc !eol) nl) ;; !eol :== ident
@

The summary index of identifiers is a file--specific set of keywords.
The index lists all identifiers defined in the file (at least all of
those recognized by the autodefinitions filter).

<<the index of identifiers>>=
(i-identifiers idx "beginindex" nl
               (list (+ i-entry))
               idx "endindex" nl)
(i-entry idx "entrybegin" spc (substring label spc !eol) nl
         (list (+ (and entrydefn (+ entryuse))))
         idx "entryend" nl
         `(e l -- (cons e l)))
(i-entrydefn idx (substring "entrydefn") spc (substring label) nl
             `(d l -- (cons d l)))
(i-entryuse idx (substring "entryuse") spc (substring label) nl
            `(u l -- (cons u l)))
@

The following chunk's name is documentation enough for the purposes of
WHYSE. See the Noweb Hacker's Guide for more information.

<<unsupported indexing keywords>>=
;; @index nl was deprecated in Noweb 2.10, and @index localdefn is not
;; widely used (assumedly) nor well-documented, so it is unsupported by
;; WHYSE (contributions for improved support are welcomed).
(i-localdefn idx "localdefn" spc !eol nl)
(i-nl idx "nl" spc !eol nl (action (error <<index nl error message>>)))
@

\subsection{cross referencing}
<<cross-referencing keywords>>=
(x-label xr (substring "label" spc label) nl)
(x-ref xr (substring "ref" spc label) nl)

(x-prev-or-next-def
 xr (substring (or "nextdef" "prevdef")) spc (substring label) nl
 `(chunk-defn label -- (append chunk-defn label)))

(x-continued-definitions-of-the-current-chunk
 xr "begindefs" nl
 (list (+ (and xr (substring "defitem") spc (substring label) nl)))
 ;; NOTE: development statement only; remove this before release.
 (action (message "peg--stack := \n%S" peg--stack))
 xr "enddefs" nl)

(x-usages
 xr "beginuses" nl
 (or (list (+ (and xr "useitem" spc (substring label) nl)))
     (and xr "notused" spc (substring label) nl))
 xr "enduses" nl)

(x-chunks xr "beginchunks" nl
          (+ x-chunk)
          xr "endchunks" nl)
(x-chunk xr "chunkbegin" spc (substring label) (substring !eol) nl
         (list (+ (list (and xr
                             (substring (or "chunkuse" "chunkdefn"))
                             spc
                             (substring label)
                             nl))))
         xr "chunkend" nl)

;; Associates label with tag (@xref tag $LABEL $TAG)
(x-tag xr "tag" spc label spc !eol nl)
(label (+ (or "-" [alnum]))) ;; A label never contains whitespace.

<<error-causing keywords>>=
;; User-errors (header and trailer) and tool-error (fatal)
;; Header and trailer's further text is irrelevant for parsing, because they cause errors.
(header (bol) "@header" ;; formatter options
        (action (error "[ERROR] Do not use totex or tohtml in your noweave pipeline.")))
(trailer (bol) "@trailer" ;; formatter
         (action (error "[ERROR] Do not use totex or tohtml in your noweave pipeline.")))
(fatal (bol) "@fatal"
       (action (error "[FATAL] There was a fatal error in the pipeline. Stash the work area and submit a bug report against Noweb, WHYSE, and other relevant tools.")))
@ 

<<index nl error message>>=
(string-join
 '("\"@index nl\" detected."
  "This indicates hand-written @ %def syntax in the Noweb source."
  "This syntax was deprecated in Noweb 2.10, and is entirely unsupported."
  "Write an autodefs AWK script for the language you are using.")
 "\n")
@ 

%%  NOTE: it would be helpful to construct this sort of parse tree at
%%  the CHUNK level, and this information can be directly sent to the
%%  database.
%% `((n . ,n)
%%   (name . ,substr)
%%   ;; Displacement: count of @nl encountered in this file so far.
%%   (offset . ,offset)
%%   (file . ,file)
%%   (section . ,section)) ;; Discover a single LaTeX sectioning command
%%                         ;; in the @text commands which are prior to
%%                         ;; this module's definition, as that is the
%%                         ;; direct parent section of this module.
%%  SQL attributes in the `module' table
%% module_number; module_name; displacement; file_name; section_name

%% The definition of a Noweb file, given by Ramsey, is simply a file
%% containing one or more chunks; minimally, a Noweb file will contain the
%% default documentation chunk.

\section{Packaging}
Installing an Emacs Lisp package is quite easy if the system is
distributed through the GNU Emacs Lisp Package Archive (GNU ELPA), and
only slightly less easy if it is distributed through MELPA
(Milkypostman's Emacs Lisp Package Archive). Other package archives have
existed, but they are all ephemeral. The most popular alternative to GNU
ELPA, Non-GNU ELPA, and MELPA is direct distribution of files through
Git servers and the use of a package by the end user to install directly
from such.

This software is in-development, so it will only be distributed directly
through Git.

WHYSE follows the form of ``simple'', single-file packages documented in
the Emacs Lisp Reference Manual. The package file, \texttt{whyse.el}, is
emitted by \texttt{notangle} which is called by the Makefile in every
target but [[clean]]. All source development occurs in \texttt{whyse.nw}
using \textsc{Polymode}.

The makefile distributed alongside whyse.nw in the tarball contains the
command-line used to tangle and weave WHYSE.

<<whyse.el>>=
<<Emacs Lisp package headers>>
<<Licensing and copyright>>
<<Commentary>>
<<Code>>
<<EOF>>
<<Emacs Lisp package headers>>=
;;; whyse.el --- noWeb HYpertext System in Emacs -*- lexical-binding: t -*-

;; Copyright © 2023 Bryce Carson

;; Author: Bryce Carson <bcars268@mtroyal.ca>
;; Created 2023-06-18
;; Keywords: tools tex hypermedia
;; URL: https://cyberscientist.ca/whyse

;; This file is not part of GNU Emacs.

@

<<whyse-pkg.el>>=
(define-package "whyse" "0.1" "noWeb HYpertext System in Emacs"
  '(<<required packages>>))
@ 

The Emacs Lisp Manual states, regarding the \texttt{Package-Requires}
element of an Emacs Lisp package header:

\begin{quote}
  Its format is a list of lists on a single line.
\end{quote}

Thus, to prevent spill--over in the printed document, the
[[<<required packages>>]] are given on separate lines in the literate
document. When the file is tangled, however, a Noweb filter will be used
to ensure that all required packages are on a single line by simply
removing the new lines from the following code chunk. The same principle
is followed for the [[<<file-local variables>>]].

<<required packages>>=
(emacs "25.1")
(emacsql "20230220")
(dash "20230617")
(peg "1.0.1")
(cl-lib "1.0")
(ts "20220822")
@

<<Licensing and copyright>>=
;; This program is free software: you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of the
;; License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see
;; <https://www.gnu.org/licenses/>.

;; If you cannot contact the author by electronic mail at the address
;; provided in the author field above, you may address mail to be
;; delivered to

;; Bryce Carson
;; Research Assistant
;; Dept. of Biology

;; Mount Royal University
;; 4825 Mount Royal Gate SW
;; Calgary, Alberta, Canada
;; T3E 6K6

<<Commentary>>=
;;; Commentary:
;; WHYSE was described by Brown and Czedjo in _A Hypertext for Literate
;; Programming_ (1991).
;;
;; Brown, M., Czejdo, B. (1991). A hypertext for literate programming.
;;    In: Akl, S.G., Fiala, F., Koczkodaj, W.W. (eds) Advances in
;;    Computing and Information — ICCI '90. ICCI 1990. Lecture Notes in
;;    Computer Science, vol 468. Springer, Berlin, Heidelberg.
;;    https://doi-org.libproxy.mtroyal.ca/10.1007/3-540-53504-7_82.
;;
;; A paper describing this implementation---written in Noweb and browsable,
;; editable, and auditable with WHYSE, or readable in the printed form---is
;; hoped to be submitted to The Journal of Open Source Software (JOSS)
;; before the year 2024. N.B.: the paper will include historical
;; information about literate programming, and citations (especially
;; of those given credit here for ideating WHYSE itself).

<<Code>>=
;;; Code:
;;;; Compiler directives
(eval-when-compile (require 'wid-edit))

;;;; Internals
<<Customization and global variables>>
<<Widgets>>
<<WHYSE project structure>>
<<buffer parsing function>>

;;;; Commands
;;;###autoload
<<WHYSE>>

<<EOF>>=
(provide 'whyse)

<<file-local variables>>
@

<<file-local variables>>=
;; Local Variables:
;; mode: emacs-lisp
;; no-byte-compile: t
;; no-native-compile: t
;; End:
@ 

\section{Indices}
\subsection{Chunks}
\nowebchunks
\subsection{Identifiers}
\nowebindex

\section{Appendices}
\subsection{A user-suggested functionality: \texttt{w-with-project}}
\label{HistoryWithProject}
It was suggested during early development that
[[<<API-like functions>>]] such as [[w-with-project]] be written. An
early version of such functionality is provided in [[w-with-project]].

<<API-like functions>>=
;; This chunk intentionally left blank at this time.
@ 

<<test.el>>=
<<buffer parsing function>>

(with-temp-buffer
  (insert (shell-command-to-string
           "make --silent --file ~/src/whyse/Makefile tool-syntax"))
  (goto-char (point-min))
  (w--parse-current-buffer-with-rules))

;; Local Variables:
;; mode: lisp-interaction-mode
;; no-byte-compile: t
;; no-native-compile: t
;; End:
@ 

\end{document}
